import { describe, it, expect, beforeAll, afterAll } from "vitest";
import { isSocketServerOnline, StartServer } from "./socketServer";
import {
  ConnectSocketAndCreateUserWithParams,
  generateValidName,
  generateValidUniqueUsername,
  KeepSocketDataUptoDate,
} from "src/scripts/testHelperFunctions";
import { sleep } from "src/scripts/tools";
import { Socket } from "socket.io-client";
import { SocketPayloadMentorshipCancel, SocketPayloadMentorshipSend } from "@shared/types/clientSocketPayload";
import { UserObj } from "@shared/types/general";
import { DBGet } from "src/db";
import { isValidUserObj } from "@shared/validation/user";

let socket1: Socket, socket2: Socket, socket3: Socket;
let socket1Data: UserObj = {},
  socket2Data: UserObj = {},
  socket3Data: UserObj = {};
beforeAll(async () => {
  if (!isSocketServerOnline()) {
    await StartServer();
  }

  socket1Data.username = await generateValidUniqueUsername(true);
  socket2Data.username = await generateValidUniqueUsername(true);
  socket3Data.username = await generateValidUniqueUsername(true);
  // create 3 users
  socket1 = await ConnectSocketAndCreateUserWithParams(
    {
      fName: generateValidName(),
      lName: generateValidName(),
      username: socket1Data.username,
    },
    true,
    "Failed to connect and create user for mentorshipRequest tests",
    {
      auth: {
        token: "testing socket1",
      },
    }
  );
  socket2 = await ConnectSocketAndCreateUserWithParams(
    {
      fName: generateValidName(),
      lName: generateValidName(),
      username: socket2Data.username,
    },
    true,
    "Failed to connect and create user for mentorshipRequest tests",
    {
      auth: {
        token: "testing socket2",
      },
    }
  );
  socket3 = await ConnectSocketAndCreateUserWithParams(
    {
      fName: generateValidName(),
      lName: generateValidName(),
      username: socket3Data.username,
    },
    true,
    "Failed to connect and create user for mentorshipRequest tests",
    {
      auth: {
        token: "testing socket3",
      },
    }
  );

  const fetchDataObjs = [socket1Data, socket2Data, socket3Data];
  for (let i = 0; i < 3; i++) {
    const res = await DBGet("user", [
      ["username", "==", fetchDataObjs[i].username],
    ]);
    if (res.length != 1) {
      throw new Error("Could not find user that was just created");
    }
    const userObj = res[0];
    if (!isValidUserObj(userObj)) {
      throw new Error("UserObj is not valid");
    }
    if (i == 0) {
      socket1Data = userObj;
      socket1.on("message", (msg) => console.log("socket1 msg", msg));
    } else if (i == 1) {
      socket2Data = userObj;
      socket2.on("message", (msg) => console.log("socket2 msg", msg));
    } else if (i == 2) {
      socket3Data = userObj;
      socket3.on("message", (msg) => console.log("socket3 msg", msg));
    }
  }

  KeepSocketDataUptoDate(socket1, socket1Data);
  KeepSocketDataUptoDate(socket2, socket2Data);
  KeepSocketDataUptoDate(socket3, socket3Data);
});


describe("Mentorship Requests", () => {
  describe('mentorshipRequest "send" action', () => {
    it("sending: fails with empty and incorrect params", async () => {
      type LooselyTypedMentorshipRequestSend = {
        [K in keyof SocketPayloadMentorshipSend]?: any;
      };

      const partialParams: (LooselyTypedMentorshipRequestSend | undefined)[] = [
        undefined,
        {},
        {
          action: "send",
        },
        {
          mentorID: "101",
        },
        {
          action: 123, // invalid type
        },
        {
          mentorID: true, // invalid type
        },
        {
          action: null,
          mentorID: null,
        },
        {
          action: undefined,
          mentorID: undefined,
        },
        {
          action: {},
          mentorID: [],
        },
        {
          action: "send",
          mentorID: 999, // invalid type
        },
        {
          action: 0,
          mentorID: "mentor",
        },
        {
          action: false,
          mentorID: {},
        },
      ];

      await Promise.all(
        partialParams.map((params) => {
          return new Promise((res, rej) => {
            socket1.emit("mentorshipRequest", params, (success: boolean) => {
              success
                ? rej("should not succeed " + JSON.stringify(params))
                : res(true);
            });
          });
        })
      );
    });

    it("sending: fails when sending request to self", async () => {
      const payload: SocketPayloadMentorshipSend = {
        action: "send",
        mentorID: socket1Data.id,
      };
      await new Promise((res, rej) => {
        socket1.emit("mentorshipRequest", payload, (success: boolean) => {
          success ? rej("should not succeed [xwjkd]") : res(true);
        });
      });
    });

    // at this point, socket1 is not accepting mentees ====================================================================
    // socket2 tries to send request to socket1, but should fail
    it("sending: fails when sending request to user who is not accepting mentees", async () => {
      const payload: SocketPayloadMentorshipSend = {
        action: "send",
        mentorID: socket1Data.id,
      };
      await new Promise((res, rej) => {
        socket2.emit("mentorshipRequest", payload, (success: boolean) => {
          success ? rej("should not succeed [hv833s]") : res(true);
        });
      });
    });

    it("sending: succeeds when sending request to different user", async () => {
      // after this point, socket1 is accepting mentees ====================================================================
      const payload: SocketPayloadMentorshipSend = {
        action: "send",
        mentorID: socket1Data.id,
      };

      await new Promise((res, rej) => {
        const socket1Update: UserObj = { acceptingMentees: true };
        socket1.emit("updateProfile", socket1Update, (success: boolean) =>
          success ? res(true) : rej("should succeed [ihcdaad9u]")
        );
      });

      // also socket1 and socket2 should have no mentorship requests at this point
      if (socket1Data.mentorshipRequests && socket1Data.mentorshipRequests.length !== 0) {
        throw new Error("socket1Data.mentorshipRequests should be undefined or empty");
      }
      if (socket2Data.mentorshipRequests && socket2Data.mentorshipRequests.length !== 0) {
        throw new Error("socket2Data.mentorshipRequests should be undefined or empty");
      }

      // socket2 sends request to socket1, should succeed
      await new Promise((res, rej) => {
        socket2.emit("mentorshipRequest", payload, (success: boolean) => {
          success ? res(true) : rej("should succeed [hv833s]");
        });
      });

      // verify that the request is in socket1's and socket2's mentorshipRequests array
      
      await sleep(500); // wait a bit for the data to be processed and sent to clients
      if (
        !socket1Data.mentorshipRequests ||
        socket1Data.mentorshipRequests.length !== 1
      ) {
        throw new Error("socket1Data.mentorshipRequests should have 1 request");
      }
      if (
        !socket2Data.mentorshipRequests ||
        socket2Data.mentorshipRequests.length !== 1
      ) {
        throw new Error("socket2Data.mentorshipRequests should have 1 request");
      }
      if (socket1Data.mentorshipRequests[0] !== socket2Data.mentorshipRequests[0]) {
        throw new Error("mentorshipRequest IDs in socket1 and socket2 do not match");
      }
    });
  });

  describe('mentorshipRequest "cancel" action', () => {
    /*
    tests for cancelling mentorship requests:

      fails:
      - empty and incorrect params
      - cancel non-existent request
      succeeds:
      - cancel existing request

      context: socket2 has sent a mentorship request to socket1
    */
    it("fails with empty and incorrect params", async () => {
      type LooselyTypedMentorshipRequestCancel = {
        [K in keyof SocketPayloadMentorshipCancel]?: any;
      };
      
      const partialParams: (LooselyTypedMentorshipRequestCancel | undefined)[] =
        [
          undefined,
          {},
          {
            action: "cancel",
          },
          {
            mentorshipRequestID: "101",
          },
          {
            action: 123, // invalid type
          },
          {
            mentorshipRequestID: true, // invalid type
          },
          {
            action: null,
            mentorshipRequestID: null,
          },
          {
            action: undefined,
            mentorshipRequestID: undefined,
          },
          {
            action: {},
            mentorshipRequestID: [],
          },
          {
            action: "cancel",
            mentorshipRequestID: 999, // invalid type
          },
          {
            action: 0,
            mentorshipRequestID: "mentor",
          },
          {
            action: false,
            mentorshipRequestID: {},
          },
          {
            action: 'bru',
            mentorshipRequestID: socket2Data.mentorshipRequests?.[0] ?? "noID", // most recent request sent by socket2
          }
        ];
        
      await Promise.all(
        partialParams.map((params) => {
          return new Promise((res, rej) => {
            socket2.emit("mentorshipRequest", params, (success: boolean) => {
              success
                ? rej("should not succeed " + JSON.stringify(params))
                : res(true);
            });
          });
        })
      );
    });

    it ('fails with non-existent mentorshipRequestID', async () => {
      const payload: SocketPayloadMentorshipCancel = {
        action: "cancel",
        mentorshipRequestID: "nonExistentID12345",
      };
      await new Promise((res, rej) => {
        socket2.emit("mentorshipRequest", payload, (success: boolean) => {
          success ? rej("should not succeed [vf42sac]") : res(true);
        });
      });
    });

    it('fails when user who did not send the request (target mentor or not) tries to cancel it', async () => {
      const payload: SocketPayloadMentorshipCancel = {
        action: "cancel",
        mentorshipRequestID: socket2Data.mentorshipRequests?.[0] ?? "noID", // most recent request sent by socket2
      };
      // target mentor should not be able to cancel it
      await new Promise((res, rej) => {
        socket1.emit("mentorshipRequest", payload, (success: boolean) => {
          success ? rej("should not succeed [cdaasd]") : res(true);
        });
      });

      // unrelated user should not be able to cancel it
      await new Promise((res, rej) => {
        socket3.emit("mentorshipRequest", payload, (success: boolean) => {
          success ? rej("should not succeed [32rfrs]") : res(true);
        });
      });
    });

    it("succeeds when cancelling existing request", async () => {
      const payload: SocketPayloadMentorshipCancel = {
        action: "cancel",
        mentorshipRequestID: socket2Data.mentorshipRequests?.[0] ?? "noID", // most recent request sent by socket2
      };
      await new Promise((res, rej) => {
        socket2.emit("mentorshipRequest", payload, (success: boolean) => {
          success ? res(true) : rej("should succeed [v8f3a]");
        });
      });
      
      // verify that the request is removed from socket1's and socket2's mentorshipRequests array
      await sleep(500); // wait a bit for the data to be processed and sent to clients
      if (socket1Data.mentorshipRequests && socket1Data.mentorshipRequests.length !== 0) {
        throw new Error("socket1Data.mentorshipRequests should be undefined or empty");
      }
      if (socket2Data.mentorshipRequests && socket2Data.mentorshipRequests.length !== 0) {
        throw new Error("socket2Data.mentorshipRequests should be undefined or empty");
      }
    });
  })
});

describe("runs after", () => {
  it("true is true", () => {
    console.log("runs after2");
    expect(true).toBe(true);
  });
});

describe("runs after", () => {
  it("true is true", () => {
    console.log("runs after3");
    expect(true).toBe(true);
  });
});

describe("runs after", () => {
  it("true is true", () => {
    console.log("runs after4");
    expect(true).toBe(true);
  });
});

afterAll(async () => {
  socket1.disconnect();
  console.log('socket1data', socket1Data);
  socket2.disconnect();
  console.log('socket2data', socket2Data);
  socket3.disconnect();
  console.log('socket3data', socket3Data);
  await sleep(1000); // give some time to disconnect before ending the process
});
